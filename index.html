<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Predictor ASL en Tiempo Real</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <link rel="stylesheet" href="entrenamiento/Web2.0/prueba.css"> 
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1><i class="fas fa-hand-sparkles"></i> Predictor ASL en Tiempo Real</h1>
        </header>
        
        <main class="main-content-area">
            <section class="card camera-card">
                <h2><i class="fa-solid fa-video"></i> Cámara y Predicción</h2>
                <div class="video-canvas-container">
                    <video id="input_video" autoplay playsinline></video>
                    <canvas id="output_canvas" width="720" height="480"></canvas>
                </div>
                
                <div class="prediction-display" id="predictionDisplay" style="display: none;">
                    <div class="prediction-letter" id="predictionLetter">--</div>
                    <div class="confidence-display">
                        Confianza: <span id="confidenceValue">--</span>%
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                    </div>
                </div>
            </section>

            <aside class="controls-column">
                <div class="card control-panel">
                    <h3><i class="fa-solid fa-folder-open"></i> Cargar Modelo</h3>
                    <a href="entrenamiento/Web2.0/prueba.html" target="_blank" class="training-link">
                        <i class="fa-solid fa-brain"></i> ¿Quieres entrenar tu propio Modelo?
                    </a>
                    
                    <div class="file-upload-group">
                        <label for="modelJsonFile" class="file-input-label m3-main-button--primary">
                            <i class="fa-solid fa-file-code"></i> Archivo JSON del Modelo
                        </label>
                        <input type="file" id="modelJsonFile" class="file-input" accept=".json">
                        <div id="modelJsonStatus" class="file-status-text error">
                            <i class="fa-solid fa-circle-xmark"></i> JSON no cargado
                        </div>
                        
                        <label for="modelWeightsFile" class="file-input-label m3-main-button--primary">
                            <i class="fa-solid fa-weight-hanging"></i> Archivo de Pesos (bin)
                        </label>
                        <input type="file" id="modelWeightsFile" class="file-input" accept=".bin">
                        <div id="modelWeightsStatus" class="file-status-text error">
                            <i class="fa-solid fa-circle-xmark"></i> Weights no cargado
                        </div>
                    </div>
                    
                    <button id="loadModelBtn" class="m3-main-button m3-main-button--secondary" disabled>
                        Cargar Modelo
                    </button>
                </div>

                <div class="card control-panel">
                    <h3><i class="fa-solid fa-chart-line"></i> Predicción</h3>
                    <button id="togglePredictionBtn" class="m3-main-button m3-main-button--primary" disabled>
                        Activar Predicción
                    </button>
                    <div class="log-container" id="predictionStatus">
                        <div class="log-entry info"><i class="fa-solid fa-circle-info"></i> Sistema listo. Carga tu modelo para comenzar.</div>
                    </div>
                </div>

                <div class="card control-panel">
                    <h3><i class="fa-solid fa-camera"></i> Estado de Cámara</h3>
                    <div class="log-container" id="cameraStatus">
                        <div class="log-entry info"><i class="fa-solid fa-circle-info"></i> Inicializando cámara...</div>
                    </div>
                </div>
                
                <div class="card control-panel instructions">
                    <h3><i class="fa-solid fa-book"></i> Instrucciones de Uso</h3>
                    <ol>
                        <li>Carga los archivos del modelo (JSON y bin)</li>
                        <li>Haz clic en "Cargar Modelo"</li>
                        <li>Activa la predicción cuando el modelo esté listo</li>
                        <li>Muestra tu mano a la cámara para reconocer gestos</li>
                        <li>La letra reconocida aparecerá con su nivel de confianza</li>
                    </ol>
                </div>
            </aside>
        </main>
        
        <footer class="app-header"> <p style="margin: 0; color: var(--md-sys-color-on-surface-variant); font-size: 0.9rem;">
                Sistema de reconocimiento de lenguaje de señas ASL | Desarrollado con MediaPipe y TensorFlow.js
            </p>
        </footer>
    </div>
    
    <script>
        // Variables globales
        let model = null;
        let modelLoaded = false;
        let predictionActive = false;
        let modelJsonFile = null;
        let modelWeightsFile = null;
        let lastPredictionTime = 0; // Para limitar la frecuencia de predicción

        // Mapeo de etiquetas ASL (ajustar según tu modelo)
        const aslLabels = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        ];

        // Referencias a elementos
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const modelJsonInput = document.getElementById('modelJsonFile');
        const modelWeightsInput = document.getElementById('modelWeightsFile');
        const loadModelBtn = document.getElementById('loadModelBtn');
        const togglePredictionBtn = document.getElementById('togglePredictionBtn');
        const predictionDisplay = document.getElementById('predictionDisplay');

        // Referencias a elementos de estado de archivo
        const modelJsonStatusText = document.getElementById('modelJsonStatus');
        const modelWeightsStatusText = document.getElementById('modelWeightsStatus');

        // Obtener utilidades de dibujo de MediaPipe
        const { drawConnectors, drawLandmarks } = window;
        const HAND_CONNECTIONS = window.HAND_CONNECTIONS;

        // Funciones de utilidad para el log de estado (con íconos M3)
        function addStatus(elementId, message, type = 'info') {
            const statusElement = document.getElementById(elementId);
            const statusItem = document.createElement('div');
            statusItem.className = `log-entry ${type}`;
            
            let iconClass = '';
            switch(type) {
                case 'info': iconClass = 'fa-solid fa-circle-info'; break;
                case 'success': iconClass = 'fa-solid fa-circle-check'; break;
                case 'error': iconClass = 'fa-solid fa-circle-xmark'; break;
                case 'warning': iconClass = 'fa-solid fa-triangle-exclamation'; break;
                default: iconClass = 'fa-solid fa-circle-info';
            }

            statusItem.innerHTML = `<i class="${iconClass}"></i><span>[${new Date().toLocaleTimeString('es-PE')}] ${message}</span>`;
            statusElement.appendChild(statusItem);
            statusElement.scrollTop = statusElement.scrollHeight; // Auto-scroll
        }


        function updatePredictionDisplay(letter, confidence) {
            document.getElementById('predictionLetter').textContent = letter;
            document.getElementById('confidenceValue').textContent = confidence.toFixed(1);
            document.getElementById('confidenceFill').style.width = `${confidence}%`;
            predictionDisplay.style.display = 'flex'; // Cambiado a 'flex' para M3 layout
        }

        // Función para normalizar landmarks (igual que en el entrenamiento)
        function normalizeLandmarks(landmarks) {
            if (!landmarks || landmarks.length === 0) return [];
            
            // Convertir a array de puntos {x, y, z}
            const points = landmarks.map(landmark => ({
                x: landmark.x,
                y: landmark.y,
                z: landmark.z
            }));
            
            // Encontrar la muñeca (primer punto)
            const wrist = points[0];
            
            // Calcular puntos relativos a la muñeca
            const relativePoints = points.map(point => ({
                x: point.x - wrist.x,
                y: point.y - wrist.y,
                z: point.z - wrist.z
            }));
            
            // Calcular la distancia máxima desde la muñeca
            let maxDistance = 0;
            for (let i = 1; i < relativePoints.length; i++) {
                const dist = Math.sqrt(
                    relativePoints[i].x ** 2 + 
                    relativePoints[i].y ** 2 + 
                    relativePoints[i].z ** 2
                );
                if (dist > maxDistance) maxDistance = dist;
            }
            
            // Normalizar por la distancia máxima (si no es cero)
            if (maxDistance > 0) {
                return relativePoints.map(point => ({
                    x: point.x / maxDistance,
                    y: point.y / maxDistance,
                    z: point.z / maxDistance
                }));
            }
            
            return relativePoints; // Si maxDistance es 0, devolver sin normalizar
        }

        // Manejo de archivos del modelo
        modelJsonInput.addEventListener('change', (e) => {
            modelJsonFile = e.target.files[0];
            if (modelJsonFile) {
                modelJsonStatusText.innerHTML = `<i class="fa-solid fa-circle-check"></i> JSON cargado: ${modelJsonFile.name}`;
                modelJsonStatusText.classList.remove('error');
                modelJsonStatusText.classList.add('success');
                checkFilesReady();
            } else {
                modelJsonStatusText.innerHTML = `<i class="fa-solid fa-circle-xmark"></i> JSON no cargado`;
                modelJsonStatusText.classList.remove('success');
                modelJsonStatusText.classList.add('error');
                checkFilesReady();
            }
        });

        modelWeightsInput.addEventListener('change', (e) => {
            modelWeightsFile = e.target.files[0];
            if (modelWeightsFile) {
                modelWeightsStatusText.innerHTML = `<i class="fa-solid fa-circle-check"></i> Weights cargado: ${modelWeightsFile.name}`;
                modelWeightsStatusText.classList.remove('error');
                modelWeightsStatusText.classList.add('success');
                checkFilesReady();
            } else {
                modelWeightsStatusText.innerHTML = `<i class="fa-solid fa-circle-xmark"></i> Weights no cargado`;
                modelWeightsStatusText.classList.remove('success');
                modelWeightsStatusText.classList.add('error');
                checkFilesReady();
            }
        });

        function checkFilesReady() {
            if (modelJsonFile && modelWeightsFile) {
                loadModelBtn.disabled = false;
                addStatus('predictionStatus', 'Archivos listos. Presiona "Cargar Modelo"', 'success');
            } else {
                loadModelBtn.disabled = true;
                addStatus('predictionStatus', 'Esperando archivos de modelo...', 'info');
            }
        }

        // Cargar modelo
        loadModelBtn.addEventListener('click', async () => {
            loadModelBtn.disabled = true;
            loadModelBtn.textContent = 'Cargando...';
            loadModelBtn.classList.remove('m3-main-button--primary'); // Quitar primary
            loadModelBtn.classList.add('m3-main-button--secondary'); // Poner secondary mientras carga
            addStatus('predictionStatus', 'Cargando modelo...');

            try {
                model = await tf.loadLayersModel(
                    tf.io.browserFiles([modelJsonFile, modelWeightsFile])
                );
                
                modelLoaded = true;
                togglePredictionBtn.disabled = false;
                loadModelBtn.textContent = 'Modelo Cargado';
                loadModelBtn.classList.remove('m3-main-button--secondary'); // Quitar secondary
                loadModelBtn.classList.add('m3-main-button--primary'); // Poner primary al cargar
                addStatus('predictionStatus', 'Modelo cargado exitosamente', 'success');
                
                // Verificar compatibilidad del modelo
                const inputShape = model.inputs[0].shape;
                if (inputShape[1] !== 63) {
                    addStatus('predictionStatus', `Advertencia: El modelo espera 63 características (tiene ${inputShape[1]})`, 'warning');
                } else {
                    addStatus('predictionStatus', 'Forma de entrada del modelo compatible: 63 características', 'success');
                }
            } catch (error) {
                addStatus('predictionStatus', `Error cargando modelo: ${error.message}`, 'error');
                loadModelBtn.disabled = false;
                loadModelBtn.textContent = 'Cargar Modelo';
                loadModelBtn.classList.remove('m3-main-button--secondary'); // Asegurar remoción de secondary
                loadModelBtn.classList.add('m3-main-button--error'); // Asume que tienes un estilo para error en CSS
                // O si no tienes m3-main-button--error, puedes poner:
                // loadModelBtn.style.backgroundColor = 'var(--md-sys-color-error)';
            }
        });

        // Toggle predicción
        togglePredictionBtn.addEventListener('click', () => {
            predictionActive = !predictionActive;
            togglePredictionBtn.textContent = predictionActive ? 'Desactivar Predicción' : 'Activar Predicción';
            
            if (predictionActive) {
                togglePredictionBtn.classList.remove('m3-main-button--primary');
                togglePredictionBtn.classList.add('m3-main-button--secondary');
            } else {
                togglePredictionBtn.classList.remove('m3-main-button--secondary');
                togglePredictionBtn.classList.add('m3-main-button--primary');
            }
            
            if (!predictionActive) {
                predictionDisplay.style.display = 'none';
            }
            
            addStatus('predictionStatus', `Predicción ${predictionActive ? 'activada' : 'desactivada'}`, 'success');
        });

        // Función para hacer predicción
        async function makePrediction(landmarks) {
            if (!modelLoaded || !predictionActive) return;

            // Limitar predicciones a 5 por segundo (200ms entre predicciones)
            const now = Date.now();
            if (now - lastPredictionTime < 200) return;
            lastPredictionTime = now;

            try {
                // Normalizar landmarks
                const normalizedLandmarks = normalizeLandmarks(landmarks);
                
                // Extraer coordenadas x, y, z de los landmarks normalizados
                // Aplanar a un array 1D
                const landmarkData = [];
                normalizedLandmarks.forEach(landmark => {
                    landmarkData.push(landmark.x, landmark.y, landmark.z);
                });

                // Asegurarse de que el input tenga la forma correcta para el modelo
                // model.inputs[0].shape es [null, 63] (Batch size, Features)
                // landmarkData debe ser un array de 63 elementos
                if (landmarkData.length !== 63) {
                     // Esto puede ocurrir si MediaPipe no detecta todos los 21 puntos (21 * 3 = 63)
                    // console.warn('Número incorrecto de características de landmark:', landmarkData.length);
                    // Opcional: mostrar un mensaje al usuario si no hay suficientes puntos
                    // addStatus('predictionStatus', 'No se detectaron suficientes puntos de la mano para la predicción.', 'warning');
                    return; // No intentar predecir con datos incompletos
                }

                // Crear tensor y hacer predicción
                const inputTensor = tf.tensor2d([landmarkData]);
                const prediction = model.predict(inputTensor);
                const predictionData = await prediction.data();

                // Encontrar la clase con mayor probabilidad
                const maxIndex = predictionData.indexOf(Math.max(...predictionData));
                const confidence = predictionData[maxIndex] * 100;
                const predictedLabel = aslLabels[maxIndex] || `Clase ${maxIndex}`;

                // Mostrar resultado solo si la confianza es alta
                if (confidence > 60) {
                    updatePredictionDisplay(predictedLabel, confidence);
                } else if (predictionDisplay.style.display === 'flex') { // Cambiado de 'block'
                    predictionDisplay.style.display = 'none';
                }

                // Limpiar tensores
                tf.dispose([inputTensor, prediction]);

            } catch (error) {
                // Only log non-MediaPipe related errors here, as MediaPipe errors
                // during onResults can be noisy if the hand is not stable.
                // console.error('Error en predicción:', error);
                addStatus('predictionStatus', `Error en predicción: ${error.message}`, 'error');
            }
        }

        // Configurar MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            selfieMode: true,
            maxNumHands: 1, // Solo una mano para ASL
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        // Procesar resultados de MediaPipe
        hands.onResults(async (results) => {
            // Limpiar y dibujar canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // Procesar landmarks si se detectan manos
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; // Solo la primera mano
                
                // Dibujar conexiones y puntos
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                    color: 'var(--md-sys-color-primary)', // Usando color primario de M3
                    lineWidth: 3
                });
                drawLandmarks(canvasCtx, landmarks, {
                    color: 'var(--md-sys-color-tertiary)', // Usando color terciario de M3 para landmarks
                    lineWidth: 2,
                    radius: 4
                });

                // Hacer predicción
                await makePrediction(landmarks);
                
                addStatus('cameraStatus', `<i class="fa-solid fa-hand"></i> Mano detectada - ${landmarks.length} puntos`);
            } else {
                addStatus('cameraStatus', `<i class="fa-solid fa-hand-point-up"></i> Muestra tu mano a la cámara...`);
                if (predictionActive) {
                    predictionDisplay.style.display = 'none';
                }
            }

            canvasCtx.restore();
        });

        // Configurar cámara
        const camera = new window.Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 720,
            height: 480
        });

        // Iniciar cámara
        camera.start().then(() => {
            addStatus('cameraStatus', `<i class="fa-solid fa-circle-play"></i> Cámara iniciada correctamente`, 'success');
        }).catch((error) => {
            addStatus('cameraStatus', `<i class="fa-solid fa-circle-exclamation"></i> Error iniciando cámara: ${error.message}`, 'error');
            addStatus('cameraStatus', `<i class="fa-solid fa-circle-info"></i> Requisitos: HTTPS/localhost, permisos de cámara`, 'error');
        });

        // Inicialización al cargar el DOM
        document.addEventListener('DOMContentLoaded', () => {
            checkFilesReady(); 
        });

    </script>
</body>
</html>